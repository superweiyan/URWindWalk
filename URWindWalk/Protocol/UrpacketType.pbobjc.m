// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: URPacketType.proto

#import "GPBProtocolBuffers_RuntimeSupport.h"
#import "UrpacketType.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - UrpacketTypeRoot

@implementation UrpacketTypeRoot

@end

#pragma mark - UrpacketTypeRoot_FileDescriptor

static GPBFileDescriptor *UrpacketTypeRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPBDebugCheckRuntimeVersion();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"URWWPacketProtocol"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum URPacketType

GPBEnumDescriptor *URPacketType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "KUriInvalid\000KUriPloginReq\000KUriPloginRes\000"
        "KUriPlogoutReq\000KUriPlogoutRes\000";
    static const int32_t values[] = {
        URPacketType_KUriInvalid,
        URPacketType_KUriPloginReq,
        URPacketType_KUriPloginRes,
        URPacketType_KUriPlogoutReq,
        URPacketType_KUriPlogoutRes,
    };
    static const char *extraTextFormatInfo = "\005\000+\000\001%H\000\002%H\000\003%I\000\004%I\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(URPacketType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:URPacketType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL URPacketType_IsValidValue(int32_t value__) {
  switch (value__) {
    case URPacketType_KUriInvalid:
    case URPacketType_KUriPloginReq:
    case URPacketType_KUriPloginRes:
    case URPacketType_KUriPlogoutReq:
    case URPacketType_KUriPlogoutRes:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ResultType

GPBEnumDescriptor *ResultType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "ResultTypeOk\000ResultTypeFail\000";
    static const int32_t values[] = {
        ResultType_ResultTypeOk,
        ResultType_ResultTypeFail,
    };
    static const char *extraTextFormatInfo = "\002\000\013A\000\001\016\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ResultType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ResultType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ResultType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ResultType_ResultTypeOk:
    case ResultType_ResultTypeFail:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PHeader

@implementation PHeader

@dynamic uid;
@dynamic seqid;
@dynamic platform;
@dynamic version;
@dynamic hasResult, result;

typedef struct PHeader__storage_ {
  uint32_t _has_storage_[1];
  uint32_t platform;
  uint32_t version;
  Result *result;
  uint64_t uid;
  uint64_t seqid;
} PHeader__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uid",
        .dataTypeSpecific.className = NULL,
        .number = PHeader_FieldNumber_Uid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PHeader__storage_, uid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "seqid",
        .dataTypeSpecific.className = NULL,
        .number = PHeader_FieldNumber_Seqid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PHeader__storage_, seqid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "platform",
        .dataTypeSpecific.className = NULL,
        .number = PHeader_FieldNumber_Platform,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PHeader__storage_, platform),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = PHeader_FieldNumber_Version,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PHeader__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "result",
        .dataTypeSpecific.className = GPBStringifySymbol(Result),
        .number = PHeader_FieldNumber_Result,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PHeader__storage_, result),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PHeader class]
                                     rootClass:[UrpacketTypeRoot class]
                                          file:UrpacketTypeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PHeader__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Result

@implementation Result

@dynamic code;
@dynamic resMsg;

typedef struct Result__storage_ {
  uint32_t _has_storage_[1];
  ResultType code;
  NSString *resMsg;
} Result__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.enumDescFunc = ResultType_EnumDescriptor,
        .number = Result_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Result__storage_, code),
        .flags = GPBFieldOptional | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "resMsg",
        .dataTypeSpecific.className = NULL,
        .number = Result_FieldNumber_ResMsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Result__storage_, resMsg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Result class]
                                     rootClass:[UrpacketTypeRoot class]
                                          file:UrpacketTypeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Result__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Result_Code_RawValue(Result *message) {
  GPBDescriptor *descriptor = [Result descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Result_FieldNumber_Code];
  return GPBGetMessageInt32Field(message, field);
}

void SetResult_Code_RawValue(Result *message, int32_t value) {
  GPBDescriptor *descriptor = [Result descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Result_FieldNumber_Code];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
